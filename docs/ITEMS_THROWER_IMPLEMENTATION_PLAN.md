# План реализации функционала броска предметов

## Описание функционала

Бэкенд отправляет событие через Socket.IO о необходимости бросить предмет. Фронтенд должен:
- Отображать предметы, подверженные физике (Matter.js)
- Бросать их в хитбокс, расположенный поверх PNG-аватара
- Визуально это должно выглядеть так, будто предметы летят прямо в персонажа

---

## Разбиение на логические модули

### 1. **Socket интеграция** (уже есть в `useSocketConnection`)
- Получение события `item:throw:requested` от бэкенда
- Валидация данных события
- Передача данных в обработчик

**Данные события:**
```typescript
interface ItemThrowEvent {
    username: string;
    rewardTitle: string;
    rewardCost: number;
    redemptionId: string;
    timestamp: string;
}
```

---

### 2. **Физический движок** (`model/usePhysicsEngine.ts`)
**Ответственность:** Инициализация и управление Matter.js

**Функции:**
- Создание `Matter.Engine`
- Создание `Matter.Render` с canvas
- Создание `Matter.Runner`
- Настройка размеров canvas
- Обработка изменения размера окна
- Очистка ресурсов при unmount

**Возвращает:**
- `syncHitbox(hitbox)` - синхронизация хитбокса с физикой
- `spawnItem(item, power)` - спавн предмета
- `destroy()` - очистка

---

### 3. **Модель хитбокса** (`model/useHitboxModel.ts`)
**Ответственность:** Управление состоянием хитбокса

**Состояние:**
- `center: Point` - центр хитбокса
- `vertices: Point[]` - вершины полигона (относительно центра)

**Методы:**
- `move(delta: Point)` - перемещение хитбокса
- `moveVertex(index, delta)` - перемещение вершины
- `addVertex(index, point)` - добавление вершины
- `removeVertex(index)` - удаление вершины
- `reset()` - сброс к значениям по умолчанию
- `restore()` - загрузка из localStorage

**Интеграция:**
- Использует `useHitboxStorage` для сохранения/загрузки

---

### 4. **Редактор хитбокса** (`lib/useHitboxEditor.ts`)
**Ответственность:** Интерактивное редактирование хитбокса

**Состояние:**
- `editorMode: boolean` - режим редактирования (показан/скрыт)
- `lastMousePosition: Point | null` - последняя позиция мыши
- `draggedVertexIndex: number | null` - индекс перетаскиваемой вершины

**Методы:**
- `onVertexLeftDown(index)` - начало перетаскивания вершины
- `onVertexRightDown(index)` - удаление вершины
- `onHitboxAreaMouseDown()` - начало перемещения хитбокса
- `hideHitbox()` / `showHitbox()` - скрытие/показ хитбокса
- `resetHitbox()` - сброс хитбокса

**Computed свойства для SVG:**
- `svgViewBox` - viewBox для SVG
- `svgStyle` - стили для позиционирования SVG
- `svgPoints` - точки для polygon

---

### 5. **Спавн предметов** (`lib/useItemSpawner.ts`)
**Ответственность:** Создание и управление предметами

**Функции:**
- `spawnItem(hitbox, item, power)` - создание предмета
  - Расчет координат спавна (над хитбоксом)
  - Расчет силы броска на основе `rewardCost`
  - Создание физического тела
  - Настройка спрайта
  - Добавление в мир
  - Автоматическое удаление через время жизни

**Параметры:**
- `hitbox: HitboxModel` - для расчета позиции спавна
- `item: ItemDescriptor` - описание предмета (изображение, звук)
- `power: number` - сила броска (из rewardCost)

---

### 6. **Рендеринг спрайтов** (`lib/useSpriteRenderer.ts`)
**Ответственность:** Загрузка и настройка изображений для Matter.js

**Функции:**
- `preloadTextures(items)` - предзагрузка всех изображений
- `getTexturePath(item)` - получение пути к текстуре
- Кэширование загруженных изображений

**Важно:**
- Matter.js требует строковый путь к изображению
- Изображения должны быть предзагружены перед использованием

---

### 7. **Обработка коллизий** (`lib/useCollisionHandler.ts`)
**Ответственность:** Обработка столкновений предметов с хитбоксом

**Функции:**
- Подписка на события `collisionStart` в Matter.js
- Определение коллизии предмета с хитбоксом
- Предотвращение повторного воспроизведения звука (`_hitPlayed` флаг)
- Вызов звукового менеджера

---

### 8. **Звуковой менеджер** (`lib/useSoundManager.ts`)
**Ответственность:** Управление звуками

**Функции:**
- `play(soundPath, volume?)` - воспроизведение звука
- Кэширование Audio элементов
- Обработка ошибок воспроизведения

---

### 9. **Хранилище хитбокса** (`lib/useHitboxStorage.ts`)
**Ответственность:** Работа с localStorage

**Функции:**
- `saveHitbox(center, vertices)` - сохранение хитбокса
- `loadHitbox()` - загрузка хитбокса
- Валидация данных при загрузке
- Обработка ошибок

---

### 10. **UI компоненты** (`ui/`)

#### `ItemsThrowerOverlay.vue`
**Ответственность:** Основной компонент для отображения

**Содержит:**
- `<canvas>` - для рендеринга Matter.js
- `<svg>` - для визуализации хитбокса (только в режиме редактирования)
- Кнопки управления (через `ItemsThrowerEditorButtons`)

**Expose:**
- `throwItem(data: ThrowItemData)` - метод для вызова извне

#### `ItemsThrowerEditorButtons.vue`
**Ответственность:** Кнопки управления редактором

**Кнопки:**
- "Hide hitbox" / "Show hitbox" - скрытие/показ хитбокса
- "Reset hitbox" - сброс к значениям по умолчанию

---

### 11. **Страница** (`pages/items-thrower/`)
**Ответственность:** Интеграция всех модулей

**Содержит:**
- Подключение к socket через `useSocketConnection`
- Обработка события `item:throw:requested`
- Использование `ItemsThrowerOverlay`
- Передача данных в `throwItem`

---

## Структура файлов (Feature Sliced Design)

```
src/frontend/
├── features/
│   └── items-thrower/              # Feature: Items Thrower
│       ├── ui/                     # UI компоненты
│       │   ├── ItemsThrowerOverlay.vue
│       │   └── ItemsThrowerEditorButtons.vue
│       ├── model/                  # Бизнес-логика
│       │   ├── usePhysicsEngine.ts
│       │   └── useHitboxModel.ts
│       ├── lib/                    # Утилиты и вспомогательные модули
│       │   ├── useHitboxEditor.ts
│       │   ├── useHitboxStorage.ts
│       │   ├── useItemSpawner.ts
│       │   ├── useSpriteRenderer.ts
│       │   ├── useCollisionHandler.ts
│       │   ├── useSoundManager.ts
│       │   └── utils.ts
│       ├── config.ts               # Конфигурация фичи
│       ├── types.ts                # Типы фичи
│       └── index.js                # Публичный API фичи
│
└── pages/
    └── items-thrower/
        └── index.vue               # Использует ItemsThrowerOverlay из feature
```

---

## План реализации (пошагово с отладкой)

### Шаг 1: Базовая физика ✅
**Цель:** Создать Matter.js engine и canvas, убедиться что всё работает

**Задачи:**
1. Создать `usePhysicsEngine.ts` с минимальной инициализацией
2. Создать простой компонент с canvas
3. Проверить что canvas отображается
4. Добавить логирование размеров canvas

**Проверка:**
- Canvas виден на странице
- Размеры canvas логируются корректно

---

### Шаг 2: Хитбокс ✅
**Цель:** Создать статичное тело хитбокса, проверить визуально

**Задачи:**
1. Создать `useHitboxModel.ts` с базовым состоянием
2. Создать `useHitboxStorage.ts` для сохранения
3. В `usePhysicsEngine` создать хитбокс-тело из вершин
4. Добавить SVG визуализацию хитбокса (красный полигон)
5. Проверить что хитбокс виден и сохраняется

**Проверка:**
- Хитбокс отображается как красный полигон
- Позиция сохраняется после перезагрузки

---

### Шаг 3: Простой предмет ✅
**Цель:** Спавн красного круга, проверить что падает

**Задачи:**
1. Добавить функцию `spawnItem` в `usePhysicsEngine`
2. Создать простое тело (круг) с `fillStyle: '#ff0000'`
3. Спавнить предмет над хитбоксом
4. Проверить что предмет падает вниз
5. Добавить логирование координат спавна и позиции

**Проверка:**
- Красный круг появляется над хитбоксом
- Круг падает вниз под действием гравитации
- Координаты логируются корректно

---

### Шаг 4: Коллизии ✅
**Цель:** Проверить что коллизии работают

**Задачи:**
1. Добавить обработчик `collisionStart` в `usePhysicsEngine`
2. Определять коллизию предмета с хитбоксом
3. Логировать каждую коллизию
4. Проверить что коллизии срабатывают

**Проверка:**
- При столкновении в консоли появляется лог
- Коллизии срабатывают корректно

---

### Шаг 5: Звуки ✅
**Цель:** Добавить звуки при коллизиях

**Задачи:**
1. Создать `useSoundManager.ts`
2. Добавить флаг `_hitPlayed` на тело предмета
3. В обработчике коллизий вызывать `soundManager.play()`
4. Проверить что звуки воспроизводятся

**Проверка:**
- При коллизии воспроизводится звук
- Звук не повторяется для одного предмета

---

### Шаг 6: Спрайты ✅
**Цель:** Добавить изображения вместо кругов

**Задачи:**
1. Создать `useSpriteRenderer.ts` для загрузки текстур
2. Предзагрузить все изображения при инициализации
3. В `spawnItem` использовать спрайты вместо `fillStyle`
4. Проверить что предметы отображаются с изображениями

**Проверка:**
- Предметы отображаются с правильными изображениями
- Изображения загружаются до спавна

---

### Шаг 7: Редактор ✅
**Цель:** Добавить возможность редактировать хитбокс

**Задачи:**
1. Создать `useHitboxEditor.ts`
2. Добавить SVG с интерактивными вершинами
3. Реализовать перетаскивание вершин и хитбокса
4. Добавить кнопки управления (скрыть/показать, сброс)
5. Проверить что редактирование работает

**Проверка:**
- Можно перетаскивать вершины
- Можно перемещать хитбокс
- Изменения сохраняются

---

### Шаг 8: Socket интеграция ✅
**Цель:** Подключить к socket событию

**Задачи:**
1. Создать страницу `pages/items-thrower/index.vue`
2. Использовать `useSocketConnection` с обработчиком `onItemThrow`
3. При получении события вызывать `overlayRef.value.throwItem(data)`
4. Добавить роут в router
5. Проверить что события обрабатываются

**Проверка:**
- При событии от бэкенда спавнится предмет
- Данные события корректно обрабатываются

---

## Конфигурация

### `config.ts`
```typescript
PHYSICS_CONFIG = {
    GRAVITY_Y: 1.2,
    ITEM_RADIUS: 18,
    ITEM_SPAWN_Y: -60,        // Смещение вверх от центра хитбокса
    ITEM_LIFETIME_MS: 6000,
    SPAWN_RANDOM_RANGE: 200,   // Разброс по X при спавне
    ITEM_RESTITUTION: 0.4,
    ITEM_FRICTION: 0.1,
    SPRITE_SIZE: 64,           // Базовый размер спрайта
}

HITBOX_CONFIG = {
    MIN_VERTICES: 4,
    SVG_PADDING: 80,
    STORAGE_KEY: 'items-thrower-hitbox-v1',
    DEFAULT_CENTER: { x: 960, y: 540 },
}

ITEMS = [
    { img: CatImage, sound: HitSqueek },
    { img: RedShoeImage, sound: ClassicHitImpactSound },
]
```

---

## Типы

### `types.ts`
```typescript
Point = { x: number; y: number; }

ItemDescriptor = {
    img: string;    // Путь к изображению
    sound: string; // Путь к звуку
}

HitboxModel = {
    center: Point;
    vertices: Point[];
    move(delta: Point): void;
    moveVertex(index: number, delta: Point): void;
    addVertex(index: number, point: Point): void;
    removeVertex(index: number): void;
    reset(): void;
    restore(): void;
}

ThrowItemData = {
    username: string;
    rewardTitle: string;
    rewardCost: number;
}
```

---

## Принципы реализации

1. **KISS** - каждый модуль делает одну простую вещь
2. **DRY** - общие утилиты вынесены в `lib/utils.ts`
3. **SOLID** - каждый composable имеет одну ответственность
4. **FSD** - четкое разделение на слои (ui, model, lib)
5. **Отладка на каждом шаге** - логирование и проверка работоспособности

---

## Порядок реализации

```
Шаг 1: Базовая физика
    ↓
Шаг 2: Хитбокс
    ↓
Шаг 3: Простой предмет
    ↓
Шаг 4: Коллизии
    ↓
Шаг 5: Звуки
    ↓
Шаг 6: Спрайты
    ↓
Шаг 7: Редактор
    ↓
Шаг 8: Socket интеграция
```

Каждый шаг проверяется отдельно перед переходом к следующему.
